#lang sicp

(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))

;我支持 Alyssa 的观点。
;
;Ben 的观点从顺序执行的角度是最自然的,但没有考虑作用域。让外部的作用域影响了内层的作用域,或者让内层作用域覆盖外层作用域。可能会产生难以发现的问题。按照 Ben 的做法,下面的语句不能执行
;
;(define (f x)
;  (define b (+ a x))
;  (define a 5)
;  (+ a b))
;(f 10)
;
;但外层定义了 a 之后,就可以执行成功。这时下面两个语句中
;
;(define b (+ a x))
;(+ a b)
;
;处于相同的作用域,但看到的具体 a 变量是完全不同的。内层的 a 覆盖了外层的 a,他们处于相同的作用域,使用同一个符合,但是含义却不相同,这会无意中产生一些难以发现的问题。
;
;Eva 的观点中。在相同作用域内,define 的顺序是任意的,define 语句可以不讲究顺序。但这种方法难以实现,需要自动分析 define 语句的相互依赖。另外我们看代码,习惯从上到下,顺序语句更容易理解。Eva 的观点中,后面的 define 语句会影响前面的语句结果,这不符合代码顺序执行,这种直观。人们更容易理解顺序,更难理解同时。
;
;Alyssa 的观点,其实是正文的做法,同时考虑了作用域和顺序执行。它遵守下面规则。
;
;    同一作用域下,相同符号的变量含义相同,访问同一个变量。
;    在符合规则 1 的情况下,代码顺序执行。
;
;这种规则相对容易理解,也容易实现。按照 Alyssa 的观点,习题中的代码会发生错误,强迫程序员编写更好的代码。
;
;Eva 定义的方案,define 可以不讲究顺序,是完全同时的。要实现这种概念上的同时性(但解释器实际是顺序执行的),就需要调整 define 语句的顺序。将所有的 define 放到作用域的前面。另外需要分析 define 语句的依赖关系,构成一个依赖图,让依赖越小的越靠前。这个依赖分析有点麻烦,类似于预先运行解释器一次。